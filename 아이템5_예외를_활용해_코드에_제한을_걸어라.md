확실하게 어떤 형태로 동작해야 하는 코드가 있다면, 예외를 활용해 제한을 걸어주는 것이 좋다. 코틀린에서는 코드의 동작에 제한을 걸 때 다음과 같은 방법을 사용할 수 있다.

- require 블록 : 아규먼트를 제한할 수 있다.
- check 블록 : 상태와 관련된 동작을 제한할 수 있다.
- assert 블록 : 어떤 것이 true인지 확인할 수 있다. assert 블록은 테스트모드에서만 동작한다.
- return 또는 throw와 함께 활용하는 Elvis 연산자

다음은 이러한 메커니즘을 사용하는 간단한 예이다.

```kotlin
// Stack<T>의 일부
fun pop(num: Int = 1): List<T> {
	require(num <= size) {
		"Cannot remove more elements than current size"
	}
	check(isOpen) { "Cannot pop from closed stack" }
	val ret = collection.take(num)
	collection = collection.drop(num)
	assert(ret.size == num)
	return ret
}
```

이렇게 제한을 걸어주면 다양한 장점이 발생한다.

- 제한을 걸면 문서를 읽지 않은 개발자도 문제를 확인할 수 있다.
- 문제가 있을 경우에 함수가 예상하지 못한 동작을 하지 않고 예외를 throw 한다. 예상하지 못한 동작을 하는 것은 예외를 throw 하는 것 보다 굉장히 위험하며, 상태를 관리하는 것이 굉장히 힘들다.이러한 제한으로 인해서 문제를 놓치지 않을 수 있고, 코드가 더 안정적으로 작동하게 된다.
- 코드가 어느 정도 자체적으로 검사된다. 따라서 이와 관련된 단위 테스트를 줄일 수 있다.
- 스마트 캐스트 기능을 활용할 수 있게 되므로, 캐스트를 적게 할 수 있다.

그럼 이러한 제한들과 관련된 내용을 조금 더 살펴보자. 일단 가장많이 사용하는 아규먼트와 관련된 내용을 살펴보자.

### 아규먼트

함수를 정의할 때 타입 시스템을 활용해서 아규먼트에 제한을 거는 코드를 많이 사용한다. 몇가지 예를 살펴보자.

- 숫자를 아규먼트로 받아서 팩토리얼을 계산한다면 숫자는 양의 정수여야 한다.
- 좌표들을 아규먼트로 받아서 클러스터를 찾을 때는 비어있지 않은 좌표 목록이 필요하다.
- 사용자로부터 이메일 주소를 입력받을 때는 값이 입력되어 있는지, 그리고 이메일 형식이 올바른지 확인해야 한다.

일반적으로 이러한 제한을 걸 때는 require 함수를 사용한다. require 함수는 제한을 확인하고, 제한을 만족하지 못할경우 예외를 throw 한다.

```kotlin
fun factorial(n: Int): Long {
	require(n >= 0)
	return if (n <= 1) 1 else factorial(n - 1) * n
}

fun findClusters(points:List<Point>): List<Cluster> {
	require(points.isNotEmpty())
}

fun sendEmail(user: User, message: String) {
	requireNotNull(user.email)
	require(isValidEmail(user.email))
}
```

이와 같은 형태의 입력 유효성 검사 코드는 함수의 가장 앞부분에 배치되므로, 읽는 사람도 쉽게 확인할 수 있다. require 함수는 조건을 만족하지 못할 때 무조건적으로 IllegalArgumentException을 발생시키므로 제한을 무시할 수 없다. 또한 다음과 같은 방법으로 람다를 활용해서 지연 메시지를 정의할 수도 있다.

```kotlin
fun factorial(n: Int): Long {
	require(n >= 0) { "Cannot calculate factorial of $n because it is smaller than 0" }
	return if (n <= 1) 1 else factorial(n - 1) * n
}
```

### 상태